# 계층형 설계 2

## 패턴 2: 추상화의 벽
- 추상화의 벽은 팀간의 책임을 명확하게 나눈다.
- **추상화의 벽**(abstraction barrier)은 세부 구현을 감춘 함수로 이루어진 계층이다.
- 함수를 사용할 때는 구현을 전혀 몰라도 함수를 쓸 수 있다.

## 추상화 벽이 있으면 구체적인 것을 신경 쓰지 않아도 된다.
- 추상화의 벽을 넘어서 직접 조작하기 위해 `splice()`함수를 호출한다면 추상화 벽 규칙을 어기는 것이다.
- 완전하지 않은 추상화 벽을 완전한 추상화 벽으로 만드는 방법은 추상화 벽에 새로운 함수를 만드는 것이다.

## 추상화 벽은 언제 사용하면 좋을까?
#### 1. 쉽게 구현을 바꾸기 위해
- 구현에 대한 확신이 없을 경우 추상화 벽을 사용하면 구현을 간접적으로 사용할 수 있다.
  - 나중에 구현을 바꾸기 쉽다.

#### 2. 코드를 읽고 쓰기 쉽게 만들기 위해
- 추상화 벽을 사용하면 세부적인 것을 신경 쓰지 않아도 된다.

#### 3. 팀 간에 조율해야 할 것을 줄이기 위해
- 각 팀에 관한 구체적인 내용을 서로 신경 쓰지 않아도 일할 수 있다.

#### 4. 주어진 문제에 집중하기 위해
- 문제의 구체적인 부분을 무시할 수 있다.
- 코드의 실수를 줄일 수 있다.

## 패턴 2 리뷰: 추상화 벽
- 서로 신경 쓰지 않아도 되는 구체적인 것을 벽을 기준으로 나눠서 서로 의존하지 않게 한다.
- 바뀌지 않을지도 모르는 코드를 언젠가 쉽게 바꿀 수 있게 만들려는 함정에 빠지지 않아야 한다.

## 패턴 3: 작은 인터페이스
- 새로운 코드를 추가할 위치에 관한 것이다.
- 인터페이스를 최소화하면 하위 계층에 불필요한 기능이 쓸데없이 커지는 것을 막을 수 있다.

- 추상화 벽에 만든 함수는 인터페이스라고 생각할 수 있다.
- 추상화 벽을 작게 만들어야 하는 이유
  - 추상화 벽에 코드가 많을수록 구현이 변경되었을 때 고쳐야 할 것이 많다.
  - 추상화 벽에 있는 코드는 낮은 수준의 코드이기 때문에 더 많은 버그가 있을 수 있다.
  - 낮은 수준의 코드는 이해하기 더 어렵다.
  - 추상화 벽에 코드가 많을수록 팀 간 조율해야 할 것도 많아진다.
  - 추상화 벽에 인터페이스가 많으면 알아야 할 것이 많아 사용하기 어렵다.

## 패턴 4: 편리한 계층
- 언제 패턴을 적용하고 언제 멈춰야 하는지 실용적인 방법을 알려준다.

### 그래프로 알 수 있는 코드에 대한 정보
- **기능적 요구사항** : 소프트웨어가 정확히 해야하는일
- **비기능적 요구사항** : 소프트웨어를 설계하는 중요한 이유

- 호출 그래프 구조는 세 가지 중요한 비기능적 요구사항을 꾸밈없이 보여준다.
  - **유지보수성**
    - 자주 바뀌는 코드는 가능한 위쪽에 있어야 한다.
  - **테스트성**
    - 아래쪽에 있는 함수를 테스트하는 것이 위쪽에 있는 함수를 테스트하는 것보다 가치 있다.
  - **재사용성**
    - 낮은 수준의 단계로 함수를 빼내면 재사용성이 더 높아진다.

- 그래프의 가장 위에 있는 코드가 고치기 쉽다.
  - 아래 있는 코드는 너무 많은 코드를 만들었기 때문이다.
  - 위에 있는 코드는 어디에서도 호출 하지 않기 때문에 고치기 쉽다.

- 아래 계층에 있는 코드는 시간이 지나도 변하지 않는 코드들이 있어햐 한다.
  - 카피-온-라이트 함수는 가장 낮은 계층이 알맞다.

- 모든 코드를 테스트 할 수 없다면 가장 아래 있는 코드를 테스트 하는 것이 좋다.
  - 가장 아래 있는 코드들은 자주 바뀌지 않기 때문에 테스트 코드도 자주 고칠 필요가 없다.

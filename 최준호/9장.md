### 살펴볼 내용
- 코드를 모듈화하기 위해 추상화 벽을 만드는 법을 배웁니다.
- 좋은 인터페이스가 어떤 것이고, 어떻게 찾는지 알아봅니다.
- 설계가 이만하면 되었다고 할 수 있는 시점을 압니다.
- 왜 계층형 설계가 유지보수와 테스트, 재상용에 도움이 되는지 이해합니다.

### 패턴 2: 추상화 벽

### 추상화 벽으로 구현을 감춥니다
- 추상화 벽은 세부 구현을 감춘 함수로 이루어진 계층입니다.
  - 추상화 벽에 있는 함수를 사용할 때는 구현을 전혀 몰라도 함수를 쓸 수 있습니다.

### 세부적인 것을 감추는 것은 대칭적입니다
- 추상화 벽을 사용하는 쪽도 만든 쪽도 서로 독립적으로 일할 수 있습니다.

### 추상화 벽이 있으면 구체적인 것을 신경 쓰지 않아도 됩니다
- 계층 구조에서 어떤 계층에 있는 함수들이 장바구니(책의 예시)와 같이 공통된 개념을 신경 쓰지 않아도 된다면 그 계층을 추상화 벽이라고 할 수 있습니다.
- 추상화 벽이 의미하는 것은 추상화 벽 위에 있는 함수가 데이터 구조를 몰라도 된다는 것을 말합니다.

### 추상화 벽은 언제 사용하면 좋을까요?
1. 쉽게 구현을 바꾸기 위해
  - 프로토타이밍 같이 최선의 구현을 확신할 수 없는 작업에 유용합니다.
  - 만약을 대비해 코드를 만드는 경우가 종종 있습니다. 쓸데없는 코드는 줄이는 것이 좋습니다! 오지 않을 수도 있는 미래를 위해 불필요한 코드를 작성하는 것은 좋지 않은 습관입니다.
2. 코드를 읽고 쓰기 쉽게 만들기 위해
3. 팀 간에 조율해야 할 것을 줄이기 위해
4. 주어진 문제에 집중하기 위해

### 패턴 2 리뷰: 추상화 벽
- 추상화 벽으로 추상화 벽 아래에 잇는 코드와 위에 있는 코드의 의존성을 없앨 수 있습니다.
- 일반적으로 추상화 벽 위에 있는 코드는 데이터 구조와 같은 구체적인 내용을 신경 쓰지 않아도 됩니다.
- 추상화 벽과 그 아래에 있는 코드는 높은 수준의 계층에서 함수가 어떻게 사용되는지 몰라도 됩니다.
- 바뀌지 않을지도 모르는 코드를 언젠가 쉽게 바꿀 수 있게 만들려는 함정에 빠지지 않아야 합니다.
- 코드를 쉽게 고치려고 추상화 벽을 사용하는 것은 아닙니다. 추상화 벽은 팀 간에 커뮤니케이션 비용을 줄이고, 복잡한 코드를 명확하게 하기 위해 전략적으로 사용해야 합니다.


### 패턴 3: 작은 인터페이스
- 작은 인터페이스 패턴은 새로운 코드를 추가할 위치에 관한 것입니다.
- 인터페이스를 최소화하면 하위 계층에 불필요한 기능이 쓸데없이 커지는 것을 막을 수 있습니다.
- 새로운 기능을 만들 때 하위 계층에 기능을 추가하거나 고치는 것보다 상위 계층에 만드는 것이 작은 인터페이스 패턴이라고 할 수 있습니다.

### 패턴 3 리뷰: 작은 인터페이스
- 추상화 벽을 작게 만들어야 하는 이유
  - 추상화 벽에 코드가 많을수록 구현이 변경되었을 때 고쳐야 할 것이 많습니다.
  - 추상화 벽에 있는 코드는 낮은 수준의 코드이기 때문에 더 많은 버그가 있을 수 있습니다.
  - 낮은 수준의 코드는 이해하기 더 어렵습니다.
  - 추상화 벽에 코드가 많을수록 팀 간 조율해야 할 것도 많아집니다.
  - 추상화 벽에 인터페이스가 많으면 알아야 할 것이 많아 사용하기 어렵습니다.
- 상위 계층에 어떤 함수를 만들 때 가능한 현재 계층에 있는 함수로 구현하는 것이 작은 인터페이스를 실천하는 방법입니다.
- 이상적인 계층은 더도 덜도 아닌 피료한 함수만 가지고 있어야 합니다. 함수는 바뀌어도 안 되고 나중에 더 늘어나도 안 됩니다. 계층이 가진 함수는 완전하고, 적고, 시간이 지나도 바뀌지 않아야 합니다. 이것이 작은 인터페이스가 전체 계층에 사용되는 이상적인 모습입니다.

### 패턴 4: 편리한 계층
- 편리한 계층 패턴은 언제 패턴을 적용하고 또 언제 멈춰야 하는지 실용적인 방법을 알려줍니다.

### 그래프로 알 수 있는 코드에 대한 정보는 무엇이 있을까요?
- 호출 그래프의 구조는 세 가지 중요한 비가능적 요구사항을 꾸밈없이 보여줍니다.
- 기능적 요구사항: 소프트웨어가 정확히 해야 하는 일을 말합니다.
- 비기능적 요구사항: 테스트를 어떻게 할 것인지, 재사용성을 잘할 수 있는지, 유지보수하기 어렵지 않은지와 같은 요구사항들 입니다.
  - 유지보수성: 요구 사항이 바뀌었을 때 가장 쉽게 고칠 수 있는 코드는 어떤 코드인가요?
  - 테스트성: 어떤 것을 테스트하는 것이 가장 중요한가요?
  - 재사용성: 어떤 함수가 재사용하기 좋나요?

### 그래프의 가장 위에 있는 코드가 고치기 가장 쉽습니다
- 가장 위에 있는 코드는 어디에서도 호출하지 않기 때문에 고치기 쉽습니다.
- 가장 낮은 계층의 함수에서 외부에 영향을 주는 동작이 바뀌면 연결된 상위 동작들이 바뀌어야 하기 때문에 낮은 계층에 있는 함수는 고치기 어렵습니다.
- 시간이 지나도 변하지 않는 코드는 가장 아래 계층에 있어야 합니다.
- 카피-온-라이트 함수는 가장 낮은 계층에 있습니다.

### 아래에 있는 코드는 테스트가 중요합니다
- 모든 코드를 테스트하는 것은 현실적이지 않습니다.
- 상위 계층은 하위 계층에 의존하기 때문에 가장 아래에 있는 코드를 테스트하는 것이 좋습니다.
- 하위 계층은 자주 바뀌지 않기 때문에 테스트도 자주 바뀌지 않아 수명이 깁니다.

### 아래에 있는 코드가 재사용하기 더 좋습니다

### 요약: 그래프가 코드에 대해 알려주는 것
- 유지보수성
  - 위로 연결된 것이 적은 함수가 바꾸기 쉽습니다.
  - 자주 바뀌는 코드는 가능한 위쪽에 있어야 합니다.
- 테스트 가능성
  - 위쪽으로 많이 연결된 함수를 테스트하는 것이 더 가치 있습니다.
- 재사용성
  - 아래쪽에 함수가 적을수록 더 재사용하기 좋습니다.     
